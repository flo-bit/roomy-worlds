<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@3.0.1 static/new-characters/Protagonist_A.glb -t -s
-->

<script lang="ts" module>
	export type ActionName =
		| '1H_Melee_Attack_Chop'
		| '1H_Melee_Attack_Jump_Chop'
		| '1H_Melee_Attack_Slice_Diagonal'
		| '1H_Melee_Attack_Slice_Horizontal'
		| '1H_Melee_Attack_Stab'
		| '1H_Ranged_Aiming'
		| '1H_Ranged_Reload'
		| '1H_Ranged_Shoot'
		| '1H_Ranged_Shooting'
		| '2H_Melee_Attack_Chop'
		| '2H_Melee_Attack_Slice'
		| '2H_Melee_Attack_Spin'
		| '2H_Melee_Attack_Spinning'
		| '2H_Melee_Attack_Stab'
		| '2H_Melee_Idle'
		| '2H_Ranged_Aiming'
		| '2H_Ranged_Reload'
		| '2H_Ranged_Shoot'
		| '2H_Ranged_Shooting'
		| 'Block'
		| 'Block_Attack'
		| 'Block_Hit'
		| 'Blocking'
		| 'Cheer'
		| 'Death_A'
		| 'Death_A_Pose'
		| 'Death_B'
		| 'Death_B_Pose'
		| 'Death_C_Pose'
		| 'Death_C_Skeletons'
		| 'Death_C_Skeletons_Resurrect'
		| 'Dodge_Backward'
		| 'Dodge_Forward'
		| 'Dodge_Left'
		| 'Dodge_Right'
		| 'Dualwield_Melee_Attack_Chop'
		| 'Dualwield_Melee_Attack_Slice'
		| 'Dualwield_Melee_Attack_Stab'
		| 'Hit_A'
		| 'Hit_B'
		| 'Idle'
		| 'Idle_B'
		| 'Idle_Combat'
		| 'Interact'
		| 'Jump_Full_Long'
		| 'Jump_Full_Short'
		| 'Jump_Idle'
		| 'Jump_Land'
		| 'Jump_Start'
		| 'Lie_Down'
		| 'Lie_Idle'
		| 'Lie_Pose'
		| 'Lie_StandUp'
		| 'PickUp'
		| 'Running_A'
		| 'Running_B'
		| 'Running_C'
		| 'Running_Strafe_Left'
		| 'Running_Strafe_Right'
		| 'Sit_Chair_Down'
		| 'Sit_Chair_Idle'
		| 'Sit_Chair_Pose'
		| 'Sit_Chair_StandUp'
		| 'Sit_Floor_Down'
		| 'Sit_Floor_Idle'
		| 'Sit_Floor_Pose'
		| 'Sit_Floor_StandUp'
		| 'Skeleton_Inactive_Standing_Pose'
		| 'Skeletons_Awaken_Floor'
		| 'Skeletons_Awaken_Floor_Long'
		| 'Skeletons_Awaken_Standing'
		| 'Skeletons_Inactive_Floor_Pose'
		| 'Spawn_Air'
		| 'Spawn_Ground'
		| 'Spawn_Ground_Skeletons'
		| 'Spellcast_Long'
		| 'Spellcast_Raise'
		| 'Spellcast_Shoot'
		| 'Spellcast_Summon'
		| 'Spellcasting'
		| 'T-Pose'
		| 'Taunt'
		| 'Taunt_Longer'
		| 'Throw'
		| 'Unarmed_Idle'
		| 'Unarmed_Melee_Attack_Kick'
		| 'Unarmed_Melee_Attack_Punch_A'
		| 'Unarmed_Melee_Attack_Punch_B'
		| 'Unarmed_Pose'
		| 'Use_Item'
		| 'Walking_A'
		| 'Walking_B'
		| 'Walking_Backwards'
		| 'Walking_C'
		| 'Walking_D_Skeletons';
</script>

<script lang="ts">
	import type * as THREE from 'three';
	import { Group } from 'three';
	import type { Snippet } from 'svelte';
	import { T, type Props } from '@threlte/core';
	import { useGltf, useGltfAnimations } from '@threlte/extras';
	import { base } from '$app/paths';

	let {
		fallback,
		error,
		children,
		ref = $bindable(),
		currentAction = 'Idle',
		transitionDuration = 0.3,
		...props
	}: Props<THREE.Group> & {
		ref?: THREE.Group;
		children?: Snippet<[{ ref: THREE.Group }]>;
		fallback?: Snippet;
		error?: Snippet<[{ error: Error }]>;
		currentAction: ActionName | undefined;
		transitionDuration?: number;
	} = $props();

	ref = new Group();

	type GLTFResult = {
		nodes: {
			Protagonist_A_ArmLeft: THREE.SkinnedMesh;
			Protagonist_A_ArmRight: THREE.SkinnedMesh;
			Protagonist_A_Backpack: THREE.SkinnedMesh;
			Protagonist_A_Body: THREE.SkinnedMesh;
			Protagonist_A_Glasses_1: THREE.SkinnedMesh;
			Protagonist_A_Glasses_2: THREE.SkinnedMesh;
			Protagonist_A_Head: THREE.SkinnedMesh;
			Protagonist_A_LegLeft: THREE.SkinnedMesh;
			Protagonist_A_LegRight: THREE.SkinnedMesh;
			root: THREE.Bone;
		};
		materials: {
			protagonist: THREE.MeshStandardMaterial;
			glass: THREE.MeshStandardMaterial;
		};
	};

	const gltf = useGltf<GLTFResult>(
		base + '/new-characters/Protagonist_A.glb' + '?r=' + Math.random().toFixed(4)
	);

	export const { actions, mixer } = useGltfAnimations<ActionName>(gltf, ref);

	let lastAction: ActionName | undefined = $state(undefined);

	$effect(() => {
		if (currentAction && $actions[currentAction] && lastAction !== currentAction) {
			if (!lastAction) {
				let action = $actions[currentAction];
				action?.play();
			} else {
				transitionTo(currentAction);
			}
			lastAction = currentAction;
		}
	});

	const transitionTo = (nextActionKey: ActionName, duration = transitionDuration) => {
		if (!lastAction) return;
		const action = $actions[lastAction];
		const nextAction = $actions[nextActionKey];

		if (!nextAction || action === nextAction) return;

		nextAction.enabled = true;
		if (action) {
			action.crossFadeTo(nextAction, duration, true);
		}
		nextAction.play();
	};
</script>

<T is={ref} dispose={false} {...props}>
	{#await gltf}
		{@render fallback?.()}
	{:then gltf}
		<T.Group name="Scene">
			<T.Group name="Rig">
				<T is={gltf.nodes.root} />
				<T.SkinnedMesh
					name="Protagonist_A_ArmLeft"
					castShadow
					receiveShadow
					geometry={gltf.nodes.Protagonist_A_ArmLeft.geometry}
					material={gltf.materials.protagonist}
					skeleton={gltf.nodes.Protagonist_A_ArmLeft.skeleton}
				/>
				<T.SkinnedMesh
					name="Protagonist_A_ArmRight"
					castShadow
					receiveShadow
					geometry={gltf.nodes.Protagonist_A_ArmRight.geometry}
					material={gltf.materials.protagonist}
					skeleton={gltf.nodes.Protagonist_A_ArmRight.skeleton}
				/>
				<T.SkinnedMesh
					name="Protagonist_A_Backpack"
					castShadow
					receiveShadow
					geometry={gltf.nodes.Protagonist_A_Backpack.geometry}
					material={gltf.materials.protagonist}
					skeleton={gltf.nodes.Protagonist_A_Backpack.skeleton}
				/>
				<T.SkinnedMesh
					name="Protagonist_A_Body"
					castShadow
					receiveShadow
					geometry={gltf.nodes.Protagonist_A_Body.geometry}
					material={gltf.materials.protagonist}
					skeleton={gltf.nodes.Protagonist_A_Body.skeleton}
				/>
				<T.Group name="Protagonist_A_Glasses">
					<T.SkinnedMesh
						name="Protagonist_A_Glasses_1"
						castShadow
						receiveShadow
						geometry={gltf.nodes.Protagonist_A_Glasses_1.geometry}
						material={gltf.materials.protagonist}
						skeleton={gltf.nodes.Protagonist_A_Glasses_1.skeleton}
					/>
					<T.SkinnedMesh
						name="Protagonist_A_Glasses_2"
						castShadow
						receiveShadow
						geometry={gltf.nodes.Protagonist_A_Glasses_2.geometry}
						material={gltf.materials.glass}
						skeleton={gltf.nodes.Protagonist_A_Glasses_2.skeleton}
					/>
				</T.Group>
				<T.SkinnedMesh
					name="Protagonist_A_Head"
					castShadow
					receiveShadow
					geometry={gltf.nodes.Protagonist_A_Head.geometry}
					material={gltf.materials.protagonist}
					skeleton={gltf.nodes.Protagonist_A_Head.skeleton}
				/>
				<T.SkinnedMesh
					name="Protagonist_A_LegLeft"
					castShadow
					receiveShadow
					geometry={gltf.nodes.Protagonist_A_LegLeft.geometry}
					material={gltf.materials.protagonist}
					skeleton={gltf.nodes.Protagonist_A_LegLeft.skeleton}
				/>
				<T.SkinnedMesh
					name="Protagonist_A_LegRight"
					castShadow
					receiveShadow
					geometry={gltf.nodes.Protagonist_A_LegRight.geometry}
					material={gltf.materials.protagonist}
					skeleton={gltf.nodes.Protagonist_A_LegRight.skeleton}
				/>
			</T.Group>
		</T.Group>
	{:catch err}
		{@render error?.({ error: err })}
	{/await}

	{@render children?.({ ref })}
</T>
