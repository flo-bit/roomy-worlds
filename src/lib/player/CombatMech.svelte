<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@3.0.1 static/new-characters/CombatMech.glb -t -s
-->

<script lang="ts">
	import type * as THREE from 'three';
	import { Group } from 'three';
	import type { Snippet } from 'svelte';
	import { T, type Props } from '@threlte/core';
	import { useGltf, useGltfAnimations } from '@threlte/extras';
	import { base } from '$app/paths';

	let {
		fallback,
		error,
		children,
		ref = $bindable(),
		currentAction = 'Idle',
		transitionDuration = 0.3,
		...props
	}: Props<THREE.Group> & {
		ref?: THREE.Group;
		children?: Snippet<[{ ref: THREE.Group }]>;
		fallback?: Snippet;
		error?: Snippet<[{ error: Error }]>;
		currentAction: ActionName | undefined;
		transitionDuration?: number;
	} = $props();

	ref = new Group();

	type ActionName =
		| '1H_Melee_Attack_Chop'
		| '1H_Melee_Attack_Jump_Chop'
		| '1H_Melee_Attack_Slice_Diagonal'
		| '1H_Melee_Attack_Slice_Horizontal'
		| '1H_Melee_Attack_Stab'
		| '1H_Ranged_Aiming'
		| '1H_Ranged_Reload'
		| '1H_Ranged_Shoot'
		| '1H_Ranged_Shooting'
		| '2H_Melee_Attack_Chop'
		| '2H_Melee_Attack_Slice'
		| '2H_Melee_Attack_Spin'
		| '2H_Melee_Attack_Spinning'
		| '2H_Melee_Attack_Stab'
		| '2H_Melee_Idle'
		| '2H_Ranged_Aiming'
		| '2H_Ranged_Reload'
		| '2H_Ranged_Shoot'
		| '2H_Ranged_Shooting'
		| 'Block'
		| 'Block_Attack'
		| 'Block_Hit'
		| 'Blocking'
		| 'Cheer'
		| 'Death_A'
		| 'Death_A_Pose'
		| 'Death_B'
		| 'Death_B_Pose'
		| 'Death_C_Pose'
		| 'Death_C_Skeletons'
		| 'Death_C_Skeletons_Resurrect'
		| 'Dodge_Backward'
		| 'Dodge_Forward'
		| 'Dodge_Left'
		| 'Dodge_Right'
		| 'Dualwield_Melee_Attack_Chop'
		| 'Dualwield_Melee_Attack_Slice'
		| 'Dualwield_Melee_Attack_Stab'
		| 'Hit_A'
		| 'Hit_B'
		| 'Idle'
		| 'Idle_B'
		| 'Idle_Combat'
		| 'Interact'
		| 'Jump_Full_Long'
		| 'Jump_Full_Short'
		| 'Jump_Idle'
		| 'Jump_Land'
		| 'Jump_Start'
		| 'Lie_Down'
		| 'Lie_Idle'
		| 'Lie_Pose'
		| 'Lie_StandUp'
		| 'PickUp'
		| 'Running_A'
		| 'Running_B'
		| 'Running_C'
		| 'Running_Strafe_Left'
		| 'Running_Strafe_Right'
		| 'Sit_Chair_Down'
		| 'Sit_Chair_Idle'
		| 'Sit_Chair_Pose'
		| 'Sit_Chair_StandUp'
		| 'Sit_Floor_Down'
		| 'Sit_Floor_Idle'
		| 'Sit_Floor_Pose'
		| 'Sit_Floor_StandUp'
		| 'Skeleton_Inactive_Standing_Pose'
		| 'Skeletons_Awaken_Floor'
		| 'Skeletons_Awaken_Floor_Long'
		| 'Skeletons_Awaken_Standing'
		| 'Skeletons_Inactive_Floor_Pose'
		| 'Spawn_Air'
		| 'Spawn_Ground'
		| 'Spawn_Ground_Skeletons'
		| 'Spellcast_Long'
		| 'Spellcast_Raise'
		| 'Spellcast_Shoot'
		| 'Spellcast_Summon'
		| 'Spellcasting'
		| 'T-Pose'
		| 'Taunt'
		| 'Taunt_Longer'
		| 'Throw'
		| 'Unarmed_Idle'
		| 'Unarmed_Melee_Attack_Kick'
		| 'Unarmed_Melee_Attack_Punch_A'
		| 'Unarmed_Melee_Attack_Punch_B'
		| 'Unarmed_Pose'
		| 'Use_Item'
		| 'Walking_A'
		| 'Walking_B'
		| 'Walking_Backwards'
		| 'Walking_C'
		| 'Walking_D_Skeletons';
	type GLTFResult = {
		nodes: {
			CombatMech_WingLeft: THREE.Mesh;
			CombatMech_WingRight: THREE.Mesh;
			CombatMech_ArmLeft: THREE.SkinnedMesh;
			CombatMech_ArmRight: THREE.SkinnedMesh;
			CombatMech_Body: THREE.SkinnedMesh;
			CombatMech_Head: THREE.SkinnedMesh;
			CombatMech_LegLeft: THREE.SkinnedMesh;
			CombatMech_LegRight: THREE.SkinnedMesh;
			CombatMech_ShoulderLeft: THREE.SkinnedMesh;
			CombatMech_ShoulderRight: THREE.SkinnedMesh;
			root: THREE.Bone;
		};
		materials: {
			combatMech: THREE.MeshStandardMaterial;
		};
	};

	const gltf = useGltf<GLTFResult>(
		base + '/new-characters/CombatMech.glb' + '?r=' + Math.random().toFixed(4)
	);

	export const { actions, mixer } = useGltfAnimations<ActionName>(gltf, ref);

	let lastAction: ActionName | undefined = $state(undefined);

	$effect(() => {
		if (currentAction && $actions[currentAction] && lastAction !== currentAction) {
			if (!lastAction) {
				let action = $actions[currentAction];
				action?.play();
			} else {
				transitionTo(currentAction);
			}
			lastAction = currentAction;
		}
	});

	const transitionTo = (nextActionKey: ActionName, duration = transitionDuration) => {
		if (!lastAction) return;
		const action = $actions[lastAction];
		const nextAction = $actions[nextActionKey];

		if (!nextAction || action === nextAction) return;

		nextAction.enabled = true;
		if (action) {
			action.crossFadeTo(nextAction, duration, true);
		}
		nextAction.play();
	};
</script>

<T is={ref} dispose={false} {...props}>
	{#await gltf}
		{@render fallback?.()}
	{:then gltf}
		<T.Group name="Scene">
			<T.Group name="Rig">
				<T is={gltf.nodes.root} />
				<T.SkinnedMesh
					name="CombatMech_ArmLeft"
					castShadow
					receiveShadow
					geometry={gltf.nodes.CombatMech_ArmLeft.geometry}
					material={gltf.materials.combatMech}
					skeleton={gltf.nodes.CombatMech_ArmLeft.skeleton}
				/>
				<T.SkinnedMesh
					name="CombatMech_ArmRight"
					castShadow
					receiveShadow
					geometry={gltf.nodes.CombatMech_ArmRight.geometry}
					material={gltf.materials.combatMech}
					skeleton={gltf.nodes.CombatMech_ArmRight.skeleton}
				/>
				<T.SkinnedMesh
					name="CombatMech_Body"
					castShadow
					receiveShadow
					geometry={gltf.nodes.CombatMech_Body.geometry}
					material={gltf.materials.combatMech}
					skeleton={gltf.nodes.CombatMech_Body.skeleton}
				/>
				<T.SkinnedMesh
					name="CombatMech_Head"
					castShadow
					receiveShadow
					geometry={gltf.nodes.CombatMech_Head.geometry}
					material={gltf.materials.combatMech}
					skeleton={gltf.nodes.CombatMech_Head.skeleton}
				/>
				<T.SkinnedMesh
					name="CombatMech_LegLeft"
					castShadow
					receiveShadow
					geometry={gltf.nodes.CombatMech_LegLeft.geometry}
					material={gltf.materials.combatMech}
					skeleton={gltf.nodes.CombatMech_LegLeft.skeleton}
				/>
				<T.SkinnedMesh
					name="CombatMech_LegRight"
					castShadow
					receiveShadow
					geometry={gltf.nodes.CombatMech_LegRight.geometry}
					material={gltf.materials.combatMech}
					skeleton={gltf.nodes.CombatMech_LegRight.skeleton}
				/>
				<T.SkinnedMesh
					name="CombatMech_ShoulderLeft"
					castShadow
					receiveShadow
					geometry={gltf.nodes.CombatMech_ShoulderLeft.geometry}
					material={gltf.materials.combatMech}
					skeleton={gltf.nodes.CombatMech_ShoulderLeft.skeleton}
				/>
				<T.SkinnedMesh
					name="CombatMech_ShoulderRight"
					castShadow
					receiveShadow
					geometry={gltf.nodes.CombatMech_ShoulderRight.geometry}
					material={gltf.materials.combatMech}
					skeleton={gltf.nodes.CombatMech_ShoulderRight.skeleton}
				/>
			</T.Group>
		</T.Group>
	{:catch err}
		{@render error?.({ error: err })}
	{/await}

	{@render children?.({ ref })}
</T>
